#pragma config(Sensor, in1,    rest_button,    sensorAnalog)
#pragma config(Sensor, in2,    help_button,    sensorAnalog)
#pragma config(Sensor, in4,    IRfarright,     sensorLineFollower)
#pragma config(Sensor, in5,    IRright,        sensorLineFollower)
#pragma config(Sensor, in6,    IRmid,          sensorLineFollower)
#pragma config(Sensor, in7,    IRleft,         sensorLineFollower)
#pragma config(Sensor, in8,    IRfarleft,      sensorLineFollower)
#pragma config(Sensor, dgtl1,  dIRfarright,    sensorDigitalIn)
#pragma config(Sensor, dgtl2,  dIRright,       sensorDigitalIn)
#pragma config(Sensor, dgtl3,  dIRmid,         sensorDigitalIn)
#pragma config(Sensor, dgtl4,  dIRleft,        sensorDigitalIn)
#pragma config(Sensor, dgtl5,  dIRfarleft,     sensorDigitalIn)
#pragma config(Sensor, dgtl6,  frontSonar,     sensorSONAR_cm)
#pragma config(Sensor, dgtl8,  backSonar,      sensorSONAR_cm)
#pragma config(Sensor, dgtl10, LED1,           sensorDigitalOut)
#pragma config(Sensor, dgtl11, LED2,           sensorDigitalOut)
#pragma config(Sensor, dgtl12, max_switch,     sensorDigitalIn)
#pragma config(Motor,  port2,           noodleBent,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           noodleStraight, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           upDownYellow,  tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           upDownRed,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           drill,         tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           leftMotor,     tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//int position = 1;
bool f_mode = true;
float speed_percent = 0.7; //manually change speed

void follow_line_backward(){
	int threshold;
	float Kp=1.0,Ki=0.0,Kd=0.0;
	float error=0.0, P=0.0, I=0.0, D=0.0, PID_value=0.0;
	int sensor[5]={0, 0, 0, 0, 0};
	int initial_motor_speed=30;
	int min = 3000;
	int max = 0;
	float previous_error;
	//bool stopped = false; //to know whether there is a horizontal line (stop)
	int IR_sensors[5] = {in4,in5,in6,in7,in8};

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

	for (int i=0; i<5; i++) {
		int val = SensorValue[IR_sensors[i]];
		if (val < min){
			min = val;
		}
		else if (val > max){
			max = val;
		}
	}
	threshold = (min+max)/2;

	//Loop
	while (SensorValue[frontSonar] > 10){
		//VOID READ SENSOR VALUES
		sensor[0]=SensorValue[IRfarright] > threshold;
		sensor[1]=SensorValue[IRright] > threshold;
		sensor[2]=SensorValue[IRmid] > threshold;
		sensor[3]=SensorValue[IRleft] > threshold;
		sensor[4]=SensorValue[IRfarleft] > threshold;

		//1 1 1 1 1 -----> horizontal black line
		//if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==true)){
		//maybe move the robot forward a bit before stopping (whole robot has to be in the zone)
		//motor[leftMotor] = 127;
		//motor[rightMotor] = 127;
		//wait1Msec(500); //robot
		//stopped = true;
		//}

		//0 0 0 0 1
		if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==true))
			error=4;

		//0 0 0 1 1
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==true)&&(sensor[4]==true))
			error=3;

		//0 0 0 1 0
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==true)&&(sensor[4]==false))
			error=2;

		//0 0 1 1 0
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==true)&&(sensor[4]==true)&&(sensor[4]==false))
			error=1;

		//0 0 1 0 0
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==true)&&(sensor[4]==false)&&(sensor[4]==false))
			error=0;

		//0 1 1 0 0
		else if((sensor[0]==false)&&(sensor[1]==true)&&(sensor[2]==true)&&(sensor[4]==false)&&(sensor[4]==false))
			error=-1;

		//0 1 0 0 0
		else if((sensor[0]==false)&&(sensor[1]==true)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==false))
			error=-2;

		//1 1 0 0 0
		else if((sensor[0]==true)&&(sensor[1]==true)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==false))
			error=-3;

		//1 0 0 0 0
		else if((sensor[0]==true)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==false))
			error=-4;

		//0 0 0 0 0
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==false))
			if(error==-4) error=-5;

		else error=5;
		//VOID CALCULATE_PID
		P = error;
		I = I + error;
		D = error - previous_error;
		PID_value = (Kp*P) + (Ki*I) + (Kd*D);
		previous_error = error;
		//VOID CONTROL MOTORS

		motor[leftMotor] = -(initial_motor_speed-PID_value);
		motor[rightMotor] = -(initial_motor_speed+PID_value);

		wait1Msec(1); //butt why?

	} //End of while loop
}

void follow_line_forward(){
	float Kp=1.0,Ki=0.0,Kd=0.0;
	float error=0.0, P=0.0, I=0.0, D=0.0, PID_value=0.0;
	int initial_motor_speed=30;
	float previous_error;
	//bool stopped = false; //to know whether there is a horizontal line (stop)
	int sensor[5];

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++//

	//DONT NEED TO CALIBRATE

	//Loop
	while (SensorValue[backSonar] > 10){
		//VOID READ SENSOR VALUES
		sensor[0] = !SensorValue[dIRfarright];
		sensor[1] = !SensorValue[dIRright];
		sensor[2] = !SensorValue[dIRmid];
		sensor[3] = !SensorValue[dIRleft];
		sensor[4] = !SensorValue[dIRfarleft];

		//1 1 1 1 1 -----> horizontal black line
		//if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==true)){
		//maybe move the robot forward a bit before stopping (whole robot has to be in the zone)
		//motor[leftMotor] = 127;
		//motor[rightMotor] = 127;
		//wait1Msec(500); //robot
		//stopped = true;
		//}

		//0 0 0 0 1
		if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==true))
			error=4;

		//0 0 0 1 1
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==true)&&(sensor[4]==true))
			error=3;

		//0 0 0 1 0
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==true)&&(sensor[4]==false))
			error=2;

		//0 0 1 1 0
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==true)&&(sensor[4]==true)&&(sensor[4]==false))
			error=1;

		//0 0 1 0 0
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==true)&&(sensor[4]==false)&&(sensor[4]==false))
			error=0;

		//0 1 1 0 0
		else if((sensor[0]==false)&&(sensor[1]==true)&&(sensor[2]==true)&&(sensor[4]==false)&&(sensor[4]==false))
			error=-1;

		//0 1 0 0 0
		else if((sensor[0]==false)&&(sensor[1]==true)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==false))
			error=-2;

		//1 1 0 0 0
		else if((sensor[0]==true)&&(sensor[1]==true)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==false))
			error=-3;

		//1 0 0 0 0
		else if((sensor[0]==true)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==false))
			error=-4;

		//0 0 0 0 0
		else if((sensor[0]==false)&&(sensor[1]==false)&&(sensor[2]==false)&&(sensor[4]==false)&&(sensor[4]==false))
			if(error==-4) error=-5;

		else error=5;
		//VOID CALCULATE_PID
		P = error;
		I = I + error;
		D = error - previous_error;
		PID_value = (Kp*P) + (Ki*I) + (Kd*D);
		previous_error = error;
		//VOID CONTROL MOTORS

		motor[leftMotor] = initial_motor_speed-PID_value;
		motor[rightMotor] = initial_motor_speed+PID_value;

		wait1Msec(1); //butt why

	} //End of while loop
}

void pickup_noodle(){
	wait1Msec(5000); //wait for the user to take the noodle
}

void score(){
	//MOVE TO THE RIGHT HEIGHT++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	motor[noodleStraight] = 127;
	wait1Msec(200); //TO BE CHANGED
}

void programming_challenge(){
	follow_line_forward(); //will stop when close to the scoring board
	score(); //Score in the hole
	follow_line_backward(); //until loading zone
	//Pick up a playing piece
	pickup_noodle();
	follow_line_forward(); //until scoring panel
	//Score in the hole
	score();
	//Come back to the begining of the path
	follow_line_backward();
}

void drive_forward(){
	if (vexRT[Btn8R] == 0 && vexRT[Btn8D] == 0 && vexRT[Btn8L] == 0 && vexRT[Btn7L] == 0){
		int c2 = vexRT[Ch2];
		int c3 = vexRT[Ch3];
		SensorValue[LED1] = 1;
		SensorValue[LED2] = 1;
		if (c3 < -10 || c3 > 10){
			motor[leftMotor] = c3;
			} else {
			motor[leftMotor] = 0;
		}
		if (c2 < -10 || c2 > 10){
			motor[rightMotor] = (int)c2*speed_percent;
			} else {
			motor[rightMotor] = 0;
		}
	}
}

void drive_backward(){
	if (vexRT[Btn8R] == 0 && vexRT[Btn8D] == 0 && vexRT[Btn8L] == 0 && vexRT[Btn7L] == 0){
		int c2 = vexRT[Ch2];
		int c3 = vexRT[Ch3];
		SensorValue[LED1] = 0;
		SensorValue[LED2] = 0;
		if (c2 < -10 || c2 > 10){
			motor[leftMotor] = -c2;
			} else {
			motor[leftMotor] = 0;
		}
		if (c3 < -10 || c3 > 10){
			motor[rightMotor] = -c3;
			} else {
			motor[rightMotor] = 0;
		}
	}
}


void user_control(){
	//CHANGING DRIVING MODES
	if (vexRT[Btn7U] && vexRT[Btn8U]){
		wait1Msec(500);
		if (vexRT[Btn7U] && vexRT[Btn8U]){
			f_mode = !f_mode;
		}
	}

	if (f_mode){
		drive_forward();
	}
	else {
		drive_backward();
	}

	//NOODLE BENT
	if (vexRT[Btn6D] == 1){
		motor[noodleBent] = 127;
	}
	else if (vexRT[Btn6U] == 1){
		motor[noodleBent] = -127;
	}
	else {
		motor[noodleBent] = 0;
	}

	//NOODLE STRAIGHT
	if (vexRT[Btn5D] == 1){
		motor[noodleStraight] = 127;
	}
	else if (vexRT[Btn5U] == 1){
		motor[noodleStraight] = -127;
	}
	else {
		motor[noodleStraight] = 0;
	}

	//NOODLE ANGLE CHANGE+++++++++++++++++++++++++++++++++++++++++++++++++++++
	/*if (vexRT[Btn7R] == 1)
	{
	if (position == 1)
	{
	while (SensorValue[fortyfiveIR] == 0) //while the IR sensor does not see the black tape
	{
	motor[drill] = 50;
	}
	motor[drill] = 0;
	position = 2;
	}

	else if (position == 2)
	{
	while (SensorValue[help_button])
	{
	motor[drill] = 50;
	}
	motor[drill] = 0;
	position = 3;
	}
	}

	if (vexRT[Btn7D] == 1)
	{
	if (position == 3)
	{
	while (SensorValue[fortyfiveIR] == 0)
	{
	motor[drill] = -50;
	}
	motor[drill] = 0;
	position = 2;
	}
	else if (position == 2)
	{
	while (SensorValue[rest_button])
	{
	motor[drill] = -50;
	}
	motor[drill] = 0;
	position = 1;
	}
	}*/

	if (vexRT[Btn7L] == 1){
		//int maxspeed = 50;
		int val = vexRT[Ch2];
		if (val < -10 || val > 10){
			motor[drill] = val/4.0;
		}
	}
	else {
		motor[drill] = 0;
	}




	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	//Up Down Mechanism+++++++++++++++++++++++++++++++++++++++

	//both motors
	/*if (SensorValue[max_switch] == 1){
	if (vexRT[Btn8U] == 1){
	int val1 = vexRT[Ch3];
	if (val1 < -10 || val1 > 10){
	motor[upDownYellow] = val1;
	motor[upDownRed] = val1;
	}
	}
	else {
	motor[upDownYellow] = 0;
	motor[upDownRed] = 0;
	}
	}*/

	if (SensorValue[max_switch] == 1){

		//one motor at a time for adjustments
		if (vexRT[Btn8L] == 1){
			int val = -vexRT[Ch3];
			if (val < -10 || val > 10){
				motor[upDownYellow] = val;
			}
		}
		else{
			motor[upDownYellow] = 0;
		}


		if (vexRT[Btn8D] == 1){
			int val = -vexRT[Ch3];
			if (val < -10 || val > 10){
				motor[upDownRed] = val;
			}
		}
		else{
			motor[upDownRed] = 0;
		}
	}
	else{
		motor[upDownRed] = 0;
		motor[upDownYellow] = 0;
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++


}

task main(){

	//When microcontroller boots up, check if buttons are pressed. If so, that means line following; else, user control
	wait1Msec(2000);
	if (vexRT[Btn5U] == 1 && vexRT[Btn5D] == 1 && vexRT[Btn6U] == 1 && vexRT[Btn6D] == 1){
		programming_challenge();
	}

	//If not programming challenge:
	//Automatically move the bent part to picking up position
	/*while (SensorValue[fortyfiveIR] == 0){
	motor[drill] = -127;
	}
	motor[drill] = 0;
	position = 2;*/

	while(true){
		user_control();
		wait1Msec(1); //butt why?
	}
}
